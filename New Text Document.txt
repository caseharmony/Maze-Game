def mazessolve_visual(f,root,update_image,gg):
    i = 0
    j = 0
    forkprocessor = []
    path = []
    maze = f[1]
    f.pop()
    while not (i == len(maze) - 1 and j == len(maze) - 1): 
        if not gg:
            f.append(maze)
            del maze
            return
        f[0].putpixel((j + j + 1, i + i + 1), (0, 255, 0))
        update_image()
        root.update()
        root.update_idletasks()
        if maze[i][j][0] == -2:
            i = forkprocessor[len(forkprocessor) - 3]
            j = forkprocessor[len(forkprocessor) - 2]
            while not (i == path[len(path) - 3] and j == path[len(path) - 2]):
                path.pop()
                path.pop()
                path.pop()
            if forkprocessor[len(forkprocessor) - 1]:
                f[0].putpixel((j + j + 1, i + i + 1), (100, 100, 100))
                update_image()
                path.pop()
                path.append(maze[i][j][1])
                if len(maze[i][j]) == 2:
                    forkprocessor.pop()
                    forkprocessor.pop()
                    forkprocessor.pop()
                else:
                    forkprocessor[len(forkprocessor) - 1] = False
                if maze[i][j][1] == 0:
                    f[0].putpixel((j + j + 1, i + i), (0, 255, 0))
                    update_image()
                    i = i - 1
                elif maze[i][j][1] == 1:
                    f[0].putpixel((j + j + 1, i + i + 2), (0, 255, 0))
                    update_image()
                    i = i + 1
                elif maze[i][j][1] == 3:
                    f[0].putpixel((j + j + 2, i + i + 1), (0, 255, 0))
                    update_image()
                    j = j + 1
                else:
                    f[0].putpixel((j + j, i + i + 1), (0, 255, 0))
                    update_image()
                    j = j - 1
                root.update_idletasks()
                root.update()
            else:
                f[0].putpixel((j + j + 1, i + i + 1), (150, 150, 150))
                update_image()
                path.pop()
                path.append(maze[i][j][2])
                forkprocessor.pop()
                forkprocessor.pop()
                forkprocessor.pop()
                if maze[i][j][2] == 0:
                    f[0].putpixel((j + j + 1, i + i), (0, 255, 0))
                    update_image()
                    i = i - 1
                elif maze[i][j][2] == 1:
                    f[0].putpixel((j + j + 1, i + i + 2), (0, 255, 0))
                    update_image()
                    i = i + 1
                elif maze[i][j][2] == 3:
                    f[0].putpixel((j + j + 2, i + i + 1), (0, 255, 0))
                    update_image()
                    j = j + 1
                else:
                    f[0].putpixel((j + j, i + i + 1), (0, 255, 0))
                    update_image()
                    j = j - 1
                root.update_idletasks()
                root.update()
            continue
        if len(maze[i][j]) == 1:
            if maze[i][j][0] == 0:
                f[0].putpixel((j + j + 1, i + i), (0, 255, 0))
                update_image()
                i = i - 1
            elif maze[i][j][0] == 1:
                f[0].putpixel((j + j + 1, i + i + 2), (0, 255, 0))
                update_image()
                i = i + 1
            elif maze[i][j][0] == 3:
                f[0].putpixel((j + j + 2, i + i + 1), (0, 255, 0))
                update_image()
                j = j + 1
            else:
                f[0].putpixel((j + j, i + i + 1), (0, 255, 0))
                update_image()
                j = j - 1
            root.update_idletasks()
            root.update()
        else:
            path.append(i)
            path.append(j)
            if (i==len(maze)-1 or j==len(maze)-1):
                for g in range(len(maze[i][j])):
                    if maze[i][j][g] == 0:
                        f[0].putpixel((j + j + 1, i + i), (0, 255, 0))
                        update_image()
                        i = i - 1
                        if i==len(maze)-1:
                            path.append(maze[i][j][g])
                            break
                    elif maze[i][j][g] == 1:
                        f[0].putpixel((j + j + 1, i + i + 2), (0, 255, 0))
                        update_image()
                        i = i + 1
                        if i==len(maze)-1:
                            path.append(maze[i][j][g])
                            break
                    elif maze[i][j][g] == 3:
                        f[0].putpixel((j + j + 2, i + i + 1), (0, 255, 0))
                        update_image()
                        j = j + 1
                        if j==len(maze)-1:
                            path.append(maze[i][j][g])
                            break
                    else:
                        f[0].putpixel((j + j, i + i + 1), (0, 255, 0))
                        update_image()
                        j = j - 1
                        if j==len(maze)-1:
                            path.append(maze[i][j][g])
                            break
            path.append(maze[i][j][0])
            forkprocessor.append(i)
            forkprocessor.append(j)
            forkprocessor.append(True)
            if maze[i][j][0] == 0:
                f[0].putpixel((j + j + 1, i + i), (0, 255, 0))
                update_image()
                i = i - 1
            elif maze[i][j][0] == 1:
                f[0].putpixel((j + j + 1, i + i + 2), (0, 255, 0))
                update_image()
                i = i + 1
            elif maze[i][j][0] == 3:
                f[0].putpixel((j + j + 2, i + i + 1), (0, 255, 0))
                update_image()
                j = j + 1
            else:
                f[0].putpixel((j + j, i + i + 1), (0, 255, 0))
                update_image()
                j = j - 1
            root.update_idletasks()
            root.update()
    for i in range(len(path) - 1, -1, -1):
        if not ((i + 1) % 3 == 0):
            path.pop(i)
    gh = f[0].size[0]
    for i in range(0, gh):
        for j in range(0, gh):
            r, g = f[0].getpixel((j, i))[:2]
            if r == 0 and (not g == 0):
                f[0].putpixel((j, i), (255, 255, 255))
    i = 0
    j = 0
    while not (i == len(maze) - 1 and j == len(maze) - 1):
        f[0].putpixel((j + j + 1, i + i + 1), (0, 255, 0))
        if len(maze[i][j]) == 1:
            if maze[i][j][0] == 0:
                f[0].putpixel((j + j + 1, i + i), (0, 255, 0))
                i = i - 1
            elif maze[i][j][0] == 1:
                f[0].putpixel((j + j + 1, i + i + 2), (0, 255, 0))
                i = i + 1
            elif maze[i][j][0] == 3:
                f[0].putpixel((j + j + 2, i + i + 1), (0, 255, 0))
                j = j + 1
            else:
                f[0].putpixel((j + j, i + i + 1), (0, 255, 0))
                j = j - 1
        else:
            f[0].putpixel((j + j + 1, i + i + 1), (0, 255, 0))
            if path[0] == 0:
                f[0].putpixel((j + j + 1, i + i), (0, 255, 0))
                i = i - 1
            elif path[0] == 1:
                f[0].putpixel((j + j + 1, i + i + 2), (0, 255, 0))
                i = i + 1
            elif path[0] == 3:
                f[0].putpixel((j + j + 2, i + i + 1), (0, 255, 0))
                j = j + 1
            else:
                f[0].putpixel((j + j, i + i + 1), (0, 255, 0))
                j = j - 1
            path.pop(0)
    f[0].putpixel((gh-2,gh-2),(0,255,0))
    update_image()